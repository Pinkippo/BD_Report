# **가비지컬렉션이란?**
- **가비지컬렉션** (Garbage Collection) 은 자바의 메모리 관리 방법 중의 하나로 JVM의 Heap 영역에서 동적으로 할당했던 메모리 영역 중 필요 없게 된 메모리 영역을 주기적으로 삭제하는 프로세스를 말합니다.

## **1. 가비지 컬렉션의 장점**
- **메모리 자동 관리** : 메모리 할당과 해제에 대한 명시적인 작업을 수행할 필요가 없어서 더 집중적으로 비즈니스 로직에 신경을 쓸 수있습니다.
- **메모리 누수 방지** : 수동으로 메모리를 해제하는 경우 실수로 메모리를 해제하지 않거나, 참조가 남아있어 메모리가 점유되는 메모리 누수가 발생할 수 있으나 방지하여 프로그램의 안정성 향상시킵니다.
- **동적 메모리 할당의 유연성** : 객체가 더 이상 사용되지 않을 때 해당 객체와 관련된 메모리를 자동으로 해제함으로써 메모리 할당의 유연성을 제공합니다.
- **성능 향상** : 효율적인 메모리 관리를 통해 프로그램의 성능을 향상시킵니다. 메모리 할당 및 해제에 대한 작업은 시스템 리소스를 소모하는데, 가비지 컬렉션은 최적의 타이밍에 메모리를 해제하여 불필요한 작업을 최소화하고 시스템 리소스를 효율적으로 활용합니다.
- **스레드 안전성** :  여러 스레드에서 동시에 실행되는 프로그램에서 안전하게 동작합니다. 메모리 할당 및 해제와 관련된 작업에 대한 동기화를 개발자가 직접 처리할 필요가 없으며, 가비지 컬렉터가 스레드 안전성을 보장합니다.

## **2. 가비지 컬렉션의 단점**
- **일시적인 중지(STW)** : 메모리 해제를 위해 실행되는 작업이므로 일시적으로 프로그램 실행을 멈출 수 있습니다. 이는 실시간 응용 프로그램이나 대규모 트래픽을 처리해야 하는 시스템에 영향을 줄 수 있습니다.

- **성능 오버헤드** : 시스템 리소스를 사용하여 메모리 관리 작업을 수행합니다. 가비지 컬렉션의 동작에 따라 CPU 및 메모리 리소스의 오버헤드가 발생할 수 있으며, 이로 인해 애플리케이션의 전체 성능이 저하될 수 있습니다.

- **예측 어려움** : 메모리 해제의 타이밍을 가비지 컬렉터가 결정하므로, 개발자는 메모리 관리의 세부적인 제어를 할 수 없습니다. 

- **메모리 사용 증가** : 모든 객체의 참조 상태를 추적해야 하므로, 추가적인 메모리 사용이 필요할 수 있습니다. 가비지 컬렉션에 필요한 데이터 구조 및 알고리즘에 따라 애플리케이션의 전체 메모리 사용량이 증가할 수 있습니다.

- **객체 소멸 제어의 어려움** : 더 이상 사용되지 않는 객체를 식별하고 해제하지만, 일부 객체는 자원 해제 등의 정리 작업을 수행해야 할 수도 있습니다. 이러한 경우에는 finalizer와 같은 메커니즘을 사용하여 객체의 소멸 시점을 제어할 수 있지만, 이는 복잡성을 증가시킬 수 있습니다.

## **3. 작동 대상**
- 가비지 컬렉션은 특정 객체가 가비지인지 아닌지 판단하기 위해서 도달성, 도달능력(**Reachability**)이라는 개념을 적용한다.
- 객체에 레퍼런스가 있다면 Reachable로 구분되고, 유효한 레퍼런스가 없다면 Unreachable로 구분해버리고 수거한다.
    - **Reachable** : 객체가 참조되고 있는 상태
    - **Unreachable** : 객체가 참조되고 있지 않은 상태

## **4. 청소 방식**
- **Mark - Sweep** 
    - 다양한 GC에서 사용되는 객체를 솎아내는 내부 알고리즘이다. (가비지 컬렉션이 동작하는 아주 기초적인 청소 과정)
    - 작동 원리는 가비지 컬렉션이 될 대상객체를 식별(Mark)하고 제거(Sweep)하며 객체가 제거되어 파편화된 메모리 영역을 앞에서부터 채워가는 작업(Compaction)을 수행하게 된다.
        - Mark - Root로부터 그래프 순회를 통해 연결된 객체들을 찾아내어 각각 어떤 객체를 참조하고 있는지 찾아서 마킹
        - Sweep - 참조하고 잇지 않은 객체 즉 Unreachable 객체들을 Heap에서 제거
        - Compact - Sweep 후에 분산된 객체들을 Heap의 시작 주소로 몰아 메모리가 할당된 부분과 그렇지 않은 부분으로 압축
    - Mark - Sweep 방식을 사용하면 루트로부터 연결이 끊긴 순환 참조되는 객체들을 모두 지울수 있다.

## **5. Heap 메모리 구조**
- JVM 개발자들은 보다 효율적인 메모리 관리를 위해 객체의 생존 시간에 따라 물리적인 Heap 영역을 나누게 되었다
    - **Young Generation**
        - 새롭게 생성된 객체가 할당(Allocation)되는 영역
        - Young 영역에 대한 가비지 컬렉션(Garbage Collection)을 Minor GC라고 부른다.
    - **Old Generation**
        - Young영역에서 Reachable 상태를 유지하여 살아남은 객체가 복사되는 영역
        - Old 영역에 대한 가비지 컬렉션(Garbage Collection)을 Major GC 또는 Full GC라고 부른다.

    - **Young 영역의 3가지 영역**
        - Eden : new를 통해 새로 생성된 객체가 위치, 살아남은 객체들은 Survivor 영역으로 보냄
        - Survivor 0 / Survivor 1 : 최소 1번의 GC 이상 살아남은 객체가 존재하는 영역, Survivor 0 또는 Survivor 1 둘 중 하나에는 꼭 비어 있어야 한다.


## **6. 동작과정**
-  **Minor GC 과정**
    - Young Generation의 공간은 Old Generation에 비해 상대적으로 작기 때문에 메모리 상의 객체를 찾아 제거하는데 적은 시간이 걸린다. -> Young Generation 영역에서 발생되는 GC를 Minor GC라 불린다.

    1. 처음 생성된 객체는 Young Generation 영역의 일부인 Eden 영역에 위치
    2. 객체가 계속 생성되어 Eden 영역이 꽉차게 되고 Minor GC가 실행
    3. Mark 동작을 통해 reachable 객체를 탐색
    4. Eden 영역에서 살아남은 객체는 1개의 Survivor 영역으로 이동
    5. Eden 영역에서 사용되지 않는 객체(unreachable)의 메모리를 해제(sweep)
    6. 살아남은 모든 객체들은 age값이 1씩 증가
    7. 또다시 Eden 영역에 신규 객체들로 가득 차게 되면 다시한번 minor GC 발생하고 mark 한다
    8. marking 한 객체들을 비어있는 Survival 1으로 이동하고 sweep
    9. 다시 살아남은 모든 객체들은 age가 1씩 증가
    10. 반복!

- **Major GC(Full GC)과정**
    - Old Generation의 객체들은 GC 과정 중에 제거되지 않은 경우 age 임계값이 차게되어 이동된 녀석들이다. -> Major GC는 객체들이 계속 Promotion되어 Old 영역의 메모리가 부족해지면 발생하게 된다.

    1. 객체의 age가 임계값(여기선 8로 설정)에 도달하게 되면,
    2. 이 객체들은 Old Generation 으로 이동된다. 이를 promotion 이라 부른다.
    3. 위의 과정이 반복되어 Old Generation 영역의 공간(메모리)가 부족하게 되면 Major GC가 발생되게 된다.